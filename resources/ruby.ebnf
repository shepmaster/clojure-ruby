<program>          = [statement] (<statement-term> [statement])* <[statement-term]> S
<statement>        = bare-statement
<inline-statement> = bare-statement S
<single-statement> = bare-statement <statement-term>
<bare-statement>   = S assignment-x
<statement-term>   = ES ("\n" | ";")

<assignment-x>          = assignment |
                          assignment-mutate |
                          method-call-logic-x
assignment              = id assignment-rhs
assignment-mutate       = id assignment-mutate-rhs
<assignment-rhs>        = S <"="> S method-call-logic-x
<assignment-mutate-rhs> = S infix-mutator S method-call-logic-x
<infix-mutator>         = "+=" | "-="

<method-call-logic-x> = method-call-logic | method-call-relop-x
method-call-logic     = method-call-logic-x S infix-symbol S method-call-logic-x
<infix-symbol>        = "&&"

<method-call-relop-x> = method-call-relop | method-call-x
method-call-relop     = method-call-relop-x S relop-symbol S method-call-relop-x
<relop-symbol>        = "<" | "==" | "!="

<method-call-x>                       = method-call |
                                        method-call-bracket |
                                        method-call-bracket-assignment |
                                        method-call-bracket-assignment-mutate |
                                        the-rest
method-call                           = method-call-x <"."> id [arglist]
method-call-bracket                   = bracket-common
method-call-bracket-assignment        = bracket-common assignment-rhs
method-call-bracket-assignment-mutate = bracket-common assignment-mutate-rhs
<bracket-common>                      = method-call-x <"["> arg <"]">
<arglist>                             = <"("> [arg (<","> arg)*] <")">
<arg>                                 = inline-statement

<the-rest> = flow-control | literal | var-ref | grouping

<flow-control> = if | while | until | case
if             = <"if"> if-branch (<"elsif"> if-branch)* <"end">
if-branch      = predicate program
while          = <"while"> predicate program <"end">
until          = <"until"> predicate program <"end">
case           = <"case"> predicate when+ <"end">
when           = S <"when"> predicate program
<predicate>    = single-statement
keyword        = "if" | "elsif" | "while" | "until" | "case" | "when" | "end"

<literal> = string | number
var-ref = id
<grouping> = <"("> statement <")">

<id>      = !(literal | keyword) #"\w+"

(* Since whitespace gets scattered about, give them small, unimportant names *)
<ES>      = <#"[ \t]*"> (* "Ending Space" *)
<S>       = <#"\s*">

number    = #"\d+"
string    = <'"'> #"[^\"]+" <'"'>
